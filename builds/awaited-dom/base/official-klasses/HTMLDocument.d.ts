import AwaitedHandler from '../AwaitedHandler';
import AwaitedPath from '../AwaitedPath';
import Constructable from '../Constructable';
import { IHTMLDocument, IDocument } from '../interfaces/official';
import { IDocumentProperties } from './Document';
export declare const getState: (instance: IHTMLDocument) => IHTMLDocumentProperties, setState: (instance: IHTMLDocument, properties: Partial<IHTMLDocumentProperties>) => void, recordProxy: (proxy: IHTMLDocument, instance: IHTMLDocument) => void;
export declare const awaitedHandler: AwaitedHandler<IHTMLDocument>;
export declare function HTMLDocumentGenerator(Document: Constructable<IDocument>): {
    new (): {
        readonly URL: Promise<string>;
        readonly anchors: import("../interfaces/super").ISuperHTMLCollection;
        readonly body: import("../interfaces/super").ISuperHTMLElement;
        readonly characterSet: Promise<string>;
        readonly compatMode: Promise<string>;
        readonly contentType: Promise<string>;
        readonly cookie: Promise<string>;
        readonly designMode: Promise<string>;
        readonly dir: Promise<string>;
        readonly doctype: import("../interfaces/official").IDocumentType;
        readonly documentElement: import("../interfaces/super").ISuperElement;
        readonly documentURI: Promise<string>;
        readonly domain: Promise<string>;
        readonly embeds: import("../interfaces/super").ISuperHTMLCollection;
        readonly featurePolicy: import("../interfaces/official").IFeaturePolicy;
        readonly forms: import("../interfaces/super").ISuperHTMLCollection;
        readonly fullscreenEnabled: Promise<boolean>;
        readonly head: import("../interfaces/official").IHTMLHeadElement;
        readonly hidden: Promise<boolean>;
        readonly images: import("../interfaces/super").ISuperHTMLCollection;
        readonly implementation: import("../interfaces/official").IDOMImplementation;
        readonly lastModified: Promise<string>;
        readonly links: import("../interfaces/super").ISuperHTMLCollection;
        readonly location: import("../interfaces/official").ILocation;
        readonly plugins: import("../interfaces/super").ISuperHTMLCollection;
        readonly readyState: Promise<import("../interfaces/official").IDocumentReadyState>;
        readonly referrer: Promise<string>;
        readonly scripts: import("../interfaces/super").ISuperHTMLCollection;
        readonly scrollingElement: import("../interfaces/super").ISuperElement;
        readonly title: Promise<string>;
        readonly visibilityState: Promise<import("../interfaces/official").IVisibilityState>;
        exitFullscreen(): Promise<void>;
        exitPointerLock(): Promise<void>;
        getElementsByClassName(classNames: string): import("../interfaces/super").ISuperHTMLCollection;
        getElementsByName(elementName: string): import("../interfaces/super").ISuperNodeList;
        getElementsByTagName(qualifiedName: string): import("../interfaces/super").ISuperHTMLCollection;
        getElementsByTagNameNS(namespace: string | null, localName: string): import("../interfaces/super").ISuperHTMLCollection;
        hasFocus(): Promise<boolean>;
        readonly ATTRIBUTE_NODE: number;
        readonly CDATA_SECTION_NODE: number;
        readonly COMMENT_NODE: number;
        readonly DOCUMENT_FRAGMENT_NODE: number;
        readonly DOCUMENT_NODE: number;
        readonly DOCUMENT_POSITION_CONTAINED_BY: number;
        readonly DOCUMENT_POSITION_CONTAINS: number;
        readonly DOCUMENT_POSITION_DISCONNECTED: number;
        readonly DOCUMENT_POSITION_FOLLOWING: number;
        readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
        readonly DOCUMENT_POSITION_PRECEDING: number;
        readonly DOCUMENT_TYPE_NODE: number;
        readonly ELEMENT_NODE: number;
        readonly ENTITY_NODE: number;
        readonly ENTITY_REFERENCE_NODE: number;
        readonly NOTATION_NODE: number;
        readonly PROCESSING_INSTRUCTION_NODE: number;
        readonly TEXT_NODE: number;
        readonly baseURI: Promise<string>;
        readonly childNodes: import("../interfaces/super").ISuperNodeList;
        readonly firstChild: import("../interfaces/super").ISuperNode;
        readonly isConnected: Promise<boolean>;
        readonly lastChild: import("../interfaces/super").ISuperNode;
        readonly nextSibling: import("../interfaces/super").ISuperNode;
        readonly nodeName: Promise<string>;
        readonly nodeType: Promise<number>;
        readonly nodeValue: Promise<string | null>;
        readonly ownerDocument: import("../interfaces/super").ISuperDocument;
        readonly parentElement: import("../interfaces/super").ISuperElement;
        readonly parentNode: import("../interfaces/super").ISuperNode;
        readonly previousSibling: import("../interfaces/super").ISuperNode;
        readonly textContent: Promise<string | null>;
        compareDocumentPosition(other: import("../interfaces/isolate").INodeIsolate): Promise<number>;
        contains(other: import("../interfaces/isolate").INodeIsolate | null): Promise<boolean>;
        getRootNode(options?: import("../interfaces/official").IGetRootNodeOptions | undefined): import("../interfaces/super").ISuperNode;
        hasChildNodes(): Promise<boolean>;
        isDefaultNamespace(namespace: string | null): Promise<boolean>;
        isEqualNode(otherNode: import("../interfaces/isolate").INodeIsolate | null): Promise<boolean>;
        isSameNode(otherNode: import("../interfaces/isolate").INodeIsolate | null): Promise<boolean>;
        lookupNamespaceURI(prefix: string | null): Promise<string | null>;
        lookupPrefix(namespace: string | null): Promise<string | null>;
        normalize(): Promise<void>;
        readonly activeElement: import("../interfaces/super").ISuperElement;
        readonly fullscreenElement: import("../interfaces/super").ISuperElement;
        readonly pointerLockElement: import("../interfaces/super").ISuperElement;
        caretPositionFromPoint(x: number, y: number): import("../interfaces/official").ICaretPosition;
        elementFromPoint(x: number, y: number): import("../interfaces/super").ISuperElement;
        getSelection(): import("../interfaces/official").ISelection;
        getElementById(elementId: string): import("../interfaces/super").ISuperElement;
        readonly childElementCount: Promise<number>;
        readonly children: import("../interfaces/super").ISuperHTMLCollection;
        readonly firstElementChild: import("../interfaces/super").ISuperElement;
        readonly lastElementChild: import("../interfaces/super").ISuperElement;
        querySelector(selectors: string): import("../interfaces/super").ISuperElement;
        querySelectorAll(selectors: string): import("../interfaces/super").ISuperNodeList;
        createExpression(expression: string, resolver?: ((prefix: string | null) => string | null) | {
            lookupNamespaceURI(prefix: string | null): string | null;
        } | null | undefined): import("../interfaces/official").IXPathExpression;
        evaluate(expression: string, contextNode: import("../interfaces/isolate").INodeIsolate, resolver?: ((prefix: string | null) => string | null) | {
            lookupNamespaceURI(prefix: string | null): string | null;
        } | null | undefined, type?: number | undefined, result?: import("../interfaces/official").IXPathResult | null | undefined): import("../interfaces/official").IXPathResult;
    };
};
export interface IHTMLDocumentProperties extends IDocumentProperties {
    awaitedPath: AwaitedPath;
    awaitedOptions: any;
}
export declare const HTMLDocumentPropertyKeys: string[];
export declare const HTMLDocumentConstantKeys: string[];
